From d5d79e5c8dbfcf49570bf280cecfb1d37efac82d Mon Sep 17 00:00:00 2001
From: Tyler Veness <calcmogul@gmail.com>
Date: Sat, 11 Jan 2025 17:45:42 -0800
Subject: [PATCH] Downgrade to C++20

---
 .styleguide                                   |  1 +
 CMakeLists.txt                                | 14 +++++++++-
 benchmarks/scalability/cart_pole/main.cpp     |  5 ++--
 benchmarks/scalability/flywheel/main.cpp      |  5 ++--
 benchmarks/scalability/util.hpp               |  8 +++---
 cmake/modules/CompilerFlags.cmake             |  2 +-
 examples/constrained_multitag/src/main.cpp    | 21 ++++++++-------
 examples/current_manager/src/main.cpp         | 11 ++++----
 .../src/main.cpp                              |  6 ++---
 examples/flywheel_ocp/src/main.cpp            |  6 ++---
 examples/frc_2022_shooter/src/main.cpp        | 12 ++++-----
 examples/frc_2024_shooter/src/main.cpp        | 12 ++++-----
 generate-choreo-patch.sh                      |  3 +++
 include/.styleguide                           |  1 +
 .../autodiff/adjoint_expression_graph.hpp     |  6 +++--
 include/sleipnir/optimization/problem.hpp     | 18 +++++++------
 include/sleipnir/util/print.hpp               | 27 ++++++++++---------
 include/sleipnir/util/spy.hpp                 |  8 +++++-
 src/util/print_diagnostics.hpp                |  7 +++--
 19 files changed, 102 insertions(+), 71 deletions(-)
 create mode 100755 generate-choreo-patch.sh

diff --git a/.styleguide b/.styleguide
index a8a4487..24e0f70 100644
--- a/.styleguide
+++ b/.styleguide
@@ -17,6 +17,7 @@ modifiableFileExclude {
 includeOtherLibs {
   ^Eigen/
   ^catch2/
+  ^fmt/
   ^nanobind/
   ^sleipnir/
 }
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 9d65051..64f5b49 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -120,6 +120,16 @@ endif()
 
 target_link_libraries(Sleipnir PUBLIC Eigen3::Eigen)
 
+# fmt dependency
+fetchcontent_declare(
+    fmt
+    GIT_REPOSITORY https://github.com/fmtlib/fmt.git
+    GIT_TAG 11.1.4
+)
+fetchcontent_makeavailable(fmt)
+
+target_link_libraries(Sleipnir PUBLIC fmt::fmt)
+
 if(BUILD_TESTING AND NOT CMAKE_CROSSCOMPILING)
     # Catch2 dependency
     fetchcontent_declare(
@@ -315,7 +325,8 @@ if(BUILD_PYTHON)
 
     # Build Sleipnir dependency directly into the wheel to avoid having to
     # configure RPATHs
-    nanobind_add_module(_jormungandr ${jormungandr_src} ${Sleipnir_src})
+    set(fmt_src ${fmt_SOURCE_DIR}/src/format.cc ${fmt_SOURCE_DIR}/src/os.cc)
+    nanobind_add_module(_jormungandr ${jormungandr_src} ${fmt_src} ${Sleipnir_src})
     compiler_flags(_jormungandr)
     target_compile_definitions(_jormungandr PRIVATE JORMUNGANDR=1)
     target_include_directories(
@@ -323,6 +334,7 @@ if(BUILD_PYTHON)
         PRIVATE
             ${CMAKE_CURRENT_SOURCE_DIR}/src
             ${CMAKE_CURRENT_SOURCE_DIR}/include
+            ${fmt_SOURCE_DIR}/include
             ${CMAKE_CURRENT_SOURCE_DIR}/jormungandr/cpp
     )
     target_link_libraries(_jormungandr PUBLIC Threads::Threads Eigen3::Eigen)
diff --git a/benchmarks/scalability/cart_pole/main.cpp b/benchmarks/scalability/cart_pole/main.cpp
index b005516..87e90fd 100644
--- a/benchmarks/scalability/cart_pole/main.cpp
+++ b/benchmarks/scalability/cart_pole/main.cpp
@@ -1,9 +1,10 @@
 // Copyright (c) Sleipnir contributors
 
 #include <chrono>
-#include <print>
 #include <vector>
 
+#include <fmt/base.h>
+
 #include "casadi.hpp"
 #include "cmdline_args.hpp"
 #include "sleipnir.hpp"
@@ -30,7 +31,7 @@ int main(int argc, char* argv[]) {
   }
   sample_sizes_to_test.emplace_back(300);
 
-  std::println("Solving cart-pole problem from N = {} to N = {}.",
+  fmt::println("Solving cart-pole problem from N = {} to N = {}.",
                sample_sizes_to_test.front(), sample_sizes_to_test.back());
   if (run_casadi) {
     run_benchmarks_and_log<casadi::Opti>(
diff --git a/benchmarks/scalability/flywheel/main.cpp b/benchmarks/scalability/flywheel/main.cpp
index 199d13b..d35b965 100644
--- a/benchmarks/scalability/flywheel/main.cpp
+++ b/benchmarks/scalability/flywheel/main.cpp
@@ -1,9 +1,10 @@
 // Copyright (c) Sleipnir contributors
 
 #include <chrono>
-#include <print>
 #include <vector>
 
+#include <fmt/base.h>
+
 #include "casadi.hpp"
 #include "cmdline_args.hpp"
 #include "sleipnir.hpp"
@@ -33,7 +34,7 @@ int main(int argc, char* argv[]) {
   }
   sample_sizes_to_test.emplace_back(5000);
 
-  std::println("Solving flywheel problem from N = {} to N = {}.",
+  fmt::println("Solving flywheel problem from N = {} to N = {}.",
                sample_sizes_to_test.front(), sample_sizes_to_test.back());
   if (run_casadi) {
     run_benchmarks_and_log<casadi::Opti>(
diff --git a/benchmarks/scalability/util.hpp b/benchmarks/scalability/util.hpp
index 759b559..b13561c 100644
--- a/benchmarks/scalability/util.hpp
+++ b/benchmarks/scalability/util.hpp
@@ -5,12 +5,12 @@
 #include <chrono>
 #include <concepts>
 #include <fstream>
-#include <print>
 #include <span>
 #include <string>
 #include <string_view>
 
 #include <casadi/casadi.hpp>
+#include <fmt/base.h>
 #include <sleipnir/optimization/problem.hpp>
 #include <sleipnir/util/function_ref.hpp>
 
@@ -99,7 +99,7 @@ int run_benchmarks_and_log(
 
     auto dt = T / N;
 
-    std::print(stderr, "N = {}...", N);
+    fmt::print(stderr, "N = {}...", N);
     run_benchmark<Problem>(
         results, [=] { return setup(dt, N); },
         [=](Problem& problem) {
@@ -114,11 +114,11 @@ int run_benchmarks_and_log(
           } else {
             if (problem.solve({.diagnostics = diagnostics}) !=
                 slp::ExitStatus::SUCCESS) {
-              std::print(stderr, " FAIL ");
+              fmt::print(stderr, " FAIL ");
             }
           }
         });
-    std::println(stderr, " done.");
+    fmt::println(stderr, " done.");
 
     results << "\n";
     std::flush(results);
diff --git a/cmake/modules/CompilerFlags.cmake b/cmake/modules/CompilerFlags.cmake
index 9eab8d0..3125281 100644
--- a/cmake/modules/CompilerFlags.cmake
+++ b/cmake/modules/CompilerFlags.cmake
@@ -22,7 +22,7 @@ macro(compiler_flags target)
         )
     endif()
 
-    target_compile_features(${target} PUBLIC cxx_std_23)
+    target_compile_features(${target} PUBLIC cxx_std_20)
     if(MSVC)
         target_compile_options(${target} PUBLIC /MP /utf-8 /bigobj)
     endif()
diff --git a/examples/constrained_multitag/src/main.cpp b/examples/constrained_multitag/src/main.cpp
index 19848cf..73f5e73 100644
--- a/examples/constrained_multitag/src/main.cpp
+++ b/examples/constrained_multitag/src/main.cpp
@@ -4,12 +4,11 @@
 //
 // The robot pose is constrained to be on the floor (z = 0).
 
-#include <print>
-#include <ranges>
 #include <utility>
 #include <vector>
 
 #include <Eigen/Core>
+#include <fmt/base.h>
 #include <sleipnir/autodiff/variable_matrix.hpp>
 #include <sleipnir/optimization/problem.hpp>
 
@@ -68,8 +67,10 @@ int main() {
 
   // Cost
   slp::Variable J = 0.0;
-  for (const auto& [field2point, observation] :
-       std::views::zip(field2points, point_observations)) {
+  for (size_t i = 0; i < field2points.size(); ++i) {
+    const auto& field2point = field2points[i];
+    const auto& observation = point_observations[i];
+
     // camera2point = field2camera⁻¹ * field2point
     // field2camera * camera2point = field2point
     auto camera2point = camera2field * field2point;
@@ -79,7 +80,7 @@ int main() {
     auto& y = camera2point[1];
     auto& z = camera2point[2];
 
-    std::println("camera2point = {}, {}, {}", x.value(), y.value(), z.value());
+    fmt::println("camera2point = {}, {}, {}", x.value(), y.value(), z.value());
 
     // coordinates observed at
     auto [u_observed, v_observed] = observation;
@@ -90,8 +91,8 @@ int main() {
     auto u = fx * X + cx;
     auto v = fy * Y + cy;
 
-    std::println("Expected u {}, saw {}", u.value(), u_observed);
-    std::println("Expected v {}, saw {}", v.value(), v_observed);
+    fmt::println("Expected u {}, saw {}", u.value(), u_observed);
+    fmt::println("Expected v {}, saw {}", v.value(), v_observed);
 
     auto u_err = u - u_observed;
     auto v_err = v - v_observed;
@@ -104,7 +105,7 @@ int main() {
 
   problem.solve({.diagnostics = true});
 
-  std::println("x = {} m", robot_x.value());
-  std::println("y = {} m", robot_y.value());
-  std::println("θ = {} rad", robot_θ.value());
+  fmt::println("x = {} m", robot_x.value());
+  fmt::println("y = {} m", robot_y.value());
+  fmt::println("θ = {} rad", robot_θ.value());
 }
diff --git a/examples/current_manager/src/main.cpp b/examples/current_manager/src/main.cpp
index 1019f85..145212b 100644
--- a/examples/current_manager/src/main.cpp
+++ b/examples/current_manager/src/main.cpp
@@ -1,7 +1,8 @@
 // Copyright (c) Sleipnir contributors
 
 #include <array>
-#include <print>
+
+#include <fmt/base.h>
 
 #include "current_manager.hpp"
 
@@ -11,13 +12,13 @@ int main() {
 
   auto currents = manager.calculate(std::array{25.0, 10.0, 5.0, 0.0});
 
-  std::print("currents = [");
+  fmt::print("currents = [");
   for (size_t i = 0; i < currents.size(); ++i) {
-    std::print("{}", currents[i]);
+    fmt::print("{}", currents[i]);
     if (i < currents.size() - 1) {
-      std::print(", ");
+      fmt::print(", ");
     }
   }
-  std::println("]");
+  fmt::println("]");
 }
 #endif
diff --git a/examples/flywheel_direct_transcription/src/main.cpp b/examples/flywheel_direct_transcription/src/main.cpp
index 10169aa..abe126c 100644
--- a/examples/flywheel_direct_transcription/src/main.cpp
+++ b/examples/flywheel_direct_transcription/src/main.cpp
@@ -2,8 +2,8 @@
 
 #include <chrono>
 #include <cmath>
-#include <print>
 
+#include <fmt/base.h>
 #include <sleipnir/optimization/problem.hpp>
 
 #ifndef RUNNING_TESTS
@@ -45,9 +45,9 @@ int main() {
   problem.solve();
 
   // The first state
-  std::println("x₀ = {}", X.value(0, 0));
+  fmt::println("x₀ = {}", X.value(0, 0));
 
   // The first input
-  std::println("u₀ = {}", U.value(0, 0));
+  fmt::println("u₀ = {}", U.value(0, 0));
 }
 #endif
diff --git a/examples/flywheel_ocp/src/main.cpp b/examples/flywheel_ocp/src/main.cpp
index c4ea7d7..d15d666 100644
--- a/examples/flywheel_ocp/src/main.cpp
+++ b/examples/flywheel_ocp/src/main.cpp
@@ -2,9 +2,9 @@
 
 #include <chrono>
 #include <cmath>
-#include <print>
 
 #include <Eigen/Core>
+#include <fmt/base.h>
 #include <sleipnir/control/ocp.hpp>
 
 #ifndef RUNNING_TESTS
@@ -45,9 +45,9 @@ int main() {
   solver.solve();
 
   // The first state
-  std::println("x₀ = {}", solver.X().value(0, 0));
+  fmt::println("x₀ = {}", solver.X().value(0, 0));
 
   // The first input
-  std::println("u₀ = {}", solver.U().value(0, 0));
+  fmt::println("u₀ = {}", solver.U().value(0, 0));
 }
 #endif
diff --git a/examples/frc_2022_shooter/src/main.cpp b/examples/frc_2022_shooter/src/main.cpp
index 7a39c12..be52419 100644
--- a/examples/frc_2022_shooter/src/main.cpp
+++ b/examples/frc_2022_shooter/src/main.cpp
@@ -2,9 +2,9 @@
 
 #include <cmath>
 #include <numbers>
-#include <print>
 
 #include <Eigen/Core>
+#include <fmt/base.h>
 #include <sleipnir/optimization/problem.hpp>
 
 // FRC 2022 shooter trajectory optimization.
@@ -151,15 +151,15 @@ int main() {
       X.block(3, 0, 3, 1).value() - robot_wrt_field.segment(3, 3);
 
   double velocity = v0.norm();
-  std::println("Velocity = {:.03} ms", velocity);
+  fmt::println("Velocity = {:.03} ms", velocity);
 
   double pitch = std::atan2(v0[2], std::hypot(v0[0], v0[1]));
-  std::println("Pitch = {:.03}°", pitch * 180.0 / std::numbers::pi);
+  fmt::println("Pitch = {:.03}°", pitch * 180.0 / std::numbers::pi);
 
   double yaw = std::atan2(v0[1], v0[0]);
-  std::println("Yaw = {:.03}°", yaw * 180.0 / std::numbers::pi);
+  fmt::println("Yaw = {:.03}°", yaw * 180.0 / std::numbers::pi);
 
-  std::println("Total time = {:.03} s", T.value());
-  std::println("dt = {:.03} ms", dt.value() * 1e3);
+  fmt::println("Total time = {:.03} s", T.value());
+  fmt::println("dt = {:.03} ms", dt.value() * 1e3);
 }
 #endif
diff --git a/examples/frc_2024_shooter/src/main.cpp b/examples/frc_2024_shooter/src/main.cpp
index 9908c6b..fbbcc04 100644
--- a/examples/frc_2024_shooter/src/main.cpp
+++ b/examples/frc_2024_shooter/src/main.cpp
@@ -2,9 +2,9 @@
 
 #include <cmath>
 #include <numbers>
-#include <print>
 
 #include <Eigen/Core>
+#include <fmt/base.h>
 #include <sleipnir/autodiff/gradient.hpp>
 #include <sleipnir/optimization/problem.hpp>
 
@@ -139,15 +139,15 @@ int main() {
   Eigen::Vector3d v0 = x.segment(3, 3).value() - robot_wrt_field.segment(3, 3);
 
   double velocity = v0.norm();
-  std::println("Velocity = {:.03} ms", velocity);
+  fmt::println("Velocity = {:.03} ms", velocity);
 
   double pitch = std::atan2(v0[2], std::hypot(v0[0], v0[1]));
-  std::println("Pitch = {:.03}°", pitch * 180.0 / std::numbers::pi);
+  fmt::println("Pitch = {:.03}°", pitch * 180.0 / std::numbers::pi);
 
   double yaw = std::atan2(v0[1], v0[0]);
-  std::println("Yaw = {:.03}°", yaw * 180.0 / std::numbers::pi);
+  fmt::println("Yaw = {:.03}°", yaw * 180.0 / std::numbers::pi);
 
-  std::println("Total time = {:.03} s", T.value());
-  std::println("dt = {:.03} ms", dt.value() * 1e3);
+  fmt::println("Total time = {:.03} s", T.value());
+  fmt::println("dt = {:.03} ms", dt.value() * 1e3);
 }
 #endif
diff --git a/generate-choreo-patch.sh b/generate-choreo-patch.sh
new file mode 100755
index 0000000..5e09cec
--- /dev/null
+++ b/generate-choreo-patch.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+git format-patch -1 --abbrev=40 --zero-commit --no-signature -- .styleguide CMakeLists.txt cmake include src
diff --git a/include/.styleguide b/include/.styleguide
index 8fb61fd..6a7f8ed 100644
--- a/include/.styleguide
+++ b/include/.styleguide
@@ -12,4 +12,5 @@ licenseUpdateExclude {
 
 includeOtherLibs {
   ^Eigen/
+  ^fmt/
 }
diff --git a/include/sleipnir/autodiff/adjoint_expression_graph.hpp b/include/sleipnir/autodiff/adjoint_expression_graph.hpp
index 6f01d5b..4dad0ff 100644
--- a/include/sleipnir/autodiff/adjoint_expression_graph.hpp
+++ b/include/sleipnir/autodiff/adjoint_expression_graph.hpp
@@ -2,7 +2,6 @@
 
 #pragma once
 
-#include <ranges>
 #include <utility>
 
 #include <Eigen/SparseCore>
@@ -154,7 +153,10 @@ class AdjointExpressionGraph {
         }
       }
     } else {
-      for (const auto& [col, node] : std::views::zip(m_col_list, m_top_list)) {
+      for (size_t i = 0; i < m_top_list.size(); ++i) {
+        const auto& col = m_col_list[i];
+        const auto& node = m_top_list[i];
+
         // Append adjoints of wrt to sparse matrix triplets
         if (col != -1 && node->adjoint != 0.0) {
           triplets.emplace_back(row, col, node->adjoint);
diff --git a/include/sleipnir/optimization/problem.hpp b/include/sleipnir/optimization/problem.hpp
index a5e44c9..3760fe6 100644
--- a/include/sleipnir/optimization/problem.hpp
+++ b/include/sleipnir/optimization/problem.hpp
@@ -303,7 +303,7 @@ class SLEIPNIR_DLLEXPORT Problem {
         slp::println("  ↳ executed {} iterations", options.max_iterations);
       }
       if (std::isfinite(options.timeout.count())) {
-        slp::println("  ↳ {} elapsed", options.timeout);
+        slp::println("  ↳ {} s elapsed", options.timeout.count());
       }
 
       if (m_decision_variables.size() == 1) {
@@ -316,11 +316,13 @@ class SLEIPNIR_DLLEXPORT Problem {
           [](const small_vector<Variable>& constraints) {
             std::array<size_t, 5> type_counts{};
             for (const auto& constraint : constraints) {
-              ++type_counts[std::to_underlying(constraint.type())];
+              ++type_counts[static_cast<uint8_t>(constraint.type())];
             }
-            for (const auto& [count, name] : std::views::zip(
-                     type_counts, std::array{"empty", "constant", "linear",
-                                             "quadratic", "nonlinear"})) {
+            for (size_t i = 0; i < type_counts.size(); ++i) {
+              constexpr std::array names{"empty", "constant", "linear",
+                                         "quadratic", "nonlinear"};
+              const auto& count = type_counts[i];
+              const auto& name = names[i];
               if (count > 0) {
                 slp::println("  ↳ {} {}", count, name);
               }
@@ -351,11 +353,11 @@ class SLEIPNIR_DLLEXPORT Problem {
                                  "nonlinear"};
 
       slp::println("\nUsing {} solver due to:", solver_name);
-      slp::println("  ↳ {} cost function", types[std::to_underlying(f_type)]);
+      slp::println("  ↳ {} cost function", types[static_cast<uint8_t>(f_type)]);
       slp::println("  ↳ {} equality constraints",
-                   types[std::to_underlying(c_e_type)]);
+                   types[static_cast<uint8_t>(c_e_type)]);
       slp::println("  ↳ {} inequality constraints",
-                   types[std::to_underlying(c_i_type)]);
+                   types[static_cast<uint8_t>(c_i_type)]);
       slp::println("");
     };
 #endif
diff --git a/include/sleipnir/util/print.hpp b/include/sleipnir/util/print.hpp
index 27a7bb3..f0085fd 100644
--- a/include/sleipnir/util/print.hpp
+++ b/include/sleipnir/util/print.hpp
@@ -3,52 +3,53 @@
 #pragma once
 
 #include <cstdio>
-#include <print>
 #include <system_error>
 #include <utility>
 
+#include <fmt/base.h>
+
 namespace slp {
 
 /**
- * Wrapper around std::print() that squelches write failure exceptions.
+ * Wrapper around fmt::print() that squelches write failure exceptions.
  */
 template <typename... T>
-inline void print(std::format_string<T...> fmt, T&&... args) {
+inline void print(fmt::format_string<T...> fmt, T&&... args) {
   try {
-    std::print(fmt, std::forward<T>(args)...);
+    fmt::print(fmt, std::forward<T>(args)...);
   } catch (const std::system_error&) {
   }
 }
 
 /**
- * Wrapper around std::print() that squelches write failure exceptions.
+ * Wrapper around fmt::print() that squelches write failure exceptions.
  */
 template <typename... T>
-inline void print(std::FILE* f, std::format_string<T...> fmt, T&&... args) {
+inline void print(std::FILE* f, fmt::format_string<T...> fmt, T&&... args) {
   try {
-    std::print(f, fmt, std::forward<T>(args)...);
+    fmt::print(f, fmt, std::forward<T>(args)...);
   } catch (const std::system_error&) {
   }
 }
 
 /**
- * Wrapper around std::println() that squelches write failure exceptions.
+ * Wrapper around fmt::println() that squelches write failure exceptions.
  */
 template <typename... T>
-inline void println(std::format_string<T...> fmt, T&&... args) {
+inline void println(fmt::format_string<T...> fmt, T&&... args) {
   try {
-    std::println(fmt, std::forward<T>(args)...);
+    fmt::println(fmt, std::forward<T>(args)...);
   } catch (const std::system_error&) {
   }
 }
 
 /**
- * Wrapper around std::println() that squelches write failure exceptions.
+ * Wrapper around fmt::println() that squelches write failure exceptions.
  */
 template <typename... T>
-inline void println(std::FILE* f, std::format_string<T...> fmt, T&&... args) {
+inline void println(std::FILE* f, fmt::format_string<T...> fmt, T&&... args) {
   try {
-    std::println(f, fmt, std::forward<T>(args)...);
+    fmt::println(f, fmt, std::forward<T>(args)...);
   } catch (const std::system_error&) {
   }
 }
diff --git a/include/sleipnir/util/spy.hpp b/include/sleipnir/util/spy.hpp
index eadafee..02d89ed 100644
--- a/include/sleipnir/util/spy.hpp
+++ b/include/sleipnir/util/spy.hpp
@@ -4,7 +4,10 @@
 
 #include <stdint.h>
 
+#include <algorithm>
+#include <array>
 #include <bit>
+#include <cstddef>
 #include <fstream>
 #include <string>
 #include <string_view>
@@ -113,7 +116,10 @@ class SLEIPNIR_DLLEXPORT Spy {
    */
   void write32le(int32_t num) {
     if constexpr (std::endian::native != std::endian::little) {
-      num = std::byteswap(num);
+      auto value_representation =
+          std::bit_cast<std::array<std::byte, sizeof(int32_t)>>(num);
+      std::ranges::reverse(value_representation);
+      num = std::bit_cast<int32_t>(value_representation);
     }
     m_file.write(reinterpret_cast<char*>(&num), sizeof(num));
   }
diff --git a/src/util/print_diagnostics.hpp b/src/util/print_diagnostics.hpp
index 821406c..2489bfe 100644
--- a/src/util/print_diagnostics.hpp
+++ b/src/util/print_diagnostics.hpp
@@ -10,7 +10,6 @@
 #include <cmath>
 #include <ranges>
 #include <string>
-#include <utility>
 
 #include <Eigen/Core>
 
@@ -198,9 +197,9 @@ void print_iteration_diagnostics(int iterations, IterationType type,
   slp::println(
       "│{:4} {:4} {:9.3f} {:12e} {:13e} {:12e} {:12e} {:.2e} {:<5} {:.2e} "
       "{:.2e} {:2d}│",
-      iterations, ITERATION_TYPES[std::to_underlying(type)], to_ms(time), error,
-      cost, infeasibility, complementarity, μ, power_of_10(δ), primal_α, dual_α,
-      backtracks);
+      iterations, ITERATION_TYPES[static_cast<uint8_t>(type)], to_ms(time),
+      error, cost, infeasibility, complementarity, μ, power_of_10(δ), primal_α,
+      dual_α, backtracks);
 }
 
 /**
-- 
2.43.0

