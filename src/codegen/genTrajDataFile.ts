import {
  DifferentialSample,
  SwerveSample,
  Trajectory
} from "../document/schema/DocumentTypes";
import { tracing } from "../document/tauriTracing";

export const TRAJ_DATA_FILENAME = "ChoreoTraj";

function round(val: number, digits: number) {
  const roundingFactor = Math.pow(10, digits);
  return Math.round(val * roundingFactor) / roundingFactor;
}

function formatPose(sample: SwerveSample | DifferentialSample): string {
  const x = round(sample.x, 3);
  const y = round(sample.y, 3);
  const heading = round(sample.heading, 3);
  return `new Pose2d(${x}, ${y}, Rotation2d.fromRadians(${heading}))`;
}

function sanitizeTrajName(trajName: string): string {
  let newName = trajName;
  for (let i = 0; i < newName.length; i++) {
    const char = newName.charAt(i);
    if (char !== " ") continue;
    newName =
      newName.slice(0, i) +
      newName.charAt(i + 1).toUpperCase() +
      newName.slice(i + 2);
  }
  newName = newName.replaceAll(/[^\w]/g, "");
  if (!newName.charAt(0).match(/[a-zA-z_]/)) {
    newName = "_" + newName;
  }
  return newName;
}

function distinguishDupes(varName: string, numDupes: number) {
  return numDupes <= 1 ? varName : `${varName}$Duplicate${numDupes - 1}`;
}

export function genTrajDataFile(
  trajectories: Trajectory[],
  packageName: string
): string {
  try {
    const content: string[] = [];
    content.push(`package ${packageName}; \n`);
    content.push(`
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import java.util.Map;

/**
 * A class containing the name, start pose, end pose, and total time of every Choreo trajectory.
 * This prevents your code from referencing deleted or misspelled trajectories,
 * and removes the need for JSON parsing to load a trajectory's essential data.
 * DO NOT MODIFY THIS FILE YOURSELF! It is automatically generated by Choreo.
 */
public record ${TRAJ_DATA_FILENAME}(
    String name,
    double totalTimeSecs,
    Pose2d initialPoseBlue,
    Pose2d endPoseBlue
) { \n`);
    // Since sanitizeTrajName() can technically produce identical variable names
    // for 2 distinct trajectories(like ABA___ and ABA),
    // we have to distinguish between duplicates like this.
    const usedVarNames: Record<string, string[]> = {};
    const staticMembers: string[] = [];
    for (const traj of trajectories) {
      const waypoints = traj.trajectory.samples;
      if (waypoints.length === 0) {
        continue;
      }
      const splitTimes = traj.trajectory.splits.concat(
        traj.trajectory.samples.length - 1
      );
      for (let i = 0; i < splitTimes.length - 1; i++) {
        let varName = sanitizeTrajName(traj.name);
        varName += splitTimes.length > 2 ? `$${i + 1}` : "";
        const trajName = traj.name + (splitTimes.length > 2 ? `.${i + 1}` : "");
        const dupes = usedVarNames[varName];
        if (dupes) {
          varName = distinguishDupes(varName, dupes.length + 1);
          usedVarNames[varName].push(trajName);
        } else {
          usedVarNames[varName] = [trajName];
        }
        let staticDef = `    public static final ChoreoTraj ${varName} = new ChoreoTraj(`;
        staticDef += `\n        "${trajName}",`;
        staticDef += `\n        ${waypoints[splitTimes[i + 1]].t},`;
        staticDef += `\n        ${formatPose(waypoints[splitTimes[i]])},`;
        staticDef += `\n        ${formatPose(waypoints[splitTimes[i + 1]])}`;
        staticDef += `\n    );`;
        staticMembers.push(staticDef);
      }
    }
    content.push(staticMembers.join("\n"));
    content.push(`\n
    /**
     * A map between trajectory names and their corresponding data.
     * This allows for trajectory data to be looked up with strings during runtime.
     */
    public static final Map<String, ChoreoTraj> all = Map.ofEntries(\n`);
    const mapEntries = [];
    for (const [varName, trajNames] of Object.entries(usedVarNames)) {
      for (let i = 0; i < trajNames.length; i++) {
        mapEntries.push(
          `        Map.entry("${trajNames[i]}", ${distinguishDupes(varName, i + 1)})`
        );
      }
    }
    content.push(mapEntries.join(",\n"));
    content.push("\n    );");
    content.push(`\n}`);
    return content.join("");
  } catch (e) {
    tracing.error("Error generating trajectory data file:", e);
    throw e;
  }
}
