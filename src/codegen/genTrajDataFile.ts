import {
  isValidIdentifier,
  NameIssue
} from "../document/path/NameIsIdentifier";
import {
  DifferentialSample,
  SwerveSample,
  Trajectory
} from "../document/schema/DocumentTypes";
import { tracing } from "../document/tauriTracing";

export const TRAJ_DATA_FILENAME = "ChoreoTraj";

function round(val: number, digits: number) {
  const roundingFactor = Math.pow(10, digits);
  return Math.round(val * roundingFactor) / roundingFactor;
}

function formatPose(sample: Pose2d): string {
  const x = round(sample.x, 3);
  const y = round(sample.y, 3);
  const heading = round(sample.heading, 3);
  return `new Pose2d(${x}, ${y}, Rotation2d.fromRadians(${heading}))`;
}

function getPose(sample: SwerveSample | DifferentialSample): Pose2d {
  const { x, y, heading } = sample;
  return { x, y, heading };
}

interface Pose2d {
  x: number;
  y: number;
  heading: number;
}

interface ChoreoTraj {
  varName: string;
  trajName: string;
  mapName: string;
  segment: number | undefined;
  totalTimeSecs: number;
  firstPose: Pose2d;
  lastPose: Pose2d;
  nameError: NameIssue | undefined;
}

function getChoreoTrajList(trajectories: Trajectory[]) {
  const trajList: ChoreoTraj[] = [];
  for (const traj of trajectories) {
    const name = traj.name;
    const nameError = isValidIdentifier(name);
    const samples = traj.trajectory.samples;
    if (samples.length < 2) {
      continue;
    }
    {
      // TODO dedupe/sanitize if necessary
      const totalTimeSecs = samples[samples.length - 1].t;
      trajList.push({
        varName: name,
        trajName: name,
        mapName: name,
        segment: undefined,
        totalTimeSecs,
        firstPose: getPose(samples[0]),
        lastPose: getPose(samples[samples.length - 1]),
        nameError
      });
    }
    const splitTimes = traj.trajectory.splits.concat(
      traj.trajectory.samples.length - 1
    );
    if (splitTimes.length > 2) {
      for (let i = 0; i < splitTimes.length - 1; i++) {
        let varName = name;
        varName += `$${i}`;
        const trajName = name;
        trajList.push({
          varName,
          trajName,
          mapName: `${trajName}$${i}`,
          segment: i,
          totalTimeSecs:
            samples[splitTimes[i + 1]].t - samples[splitTimes[i]].t,
          firstPose: getPose(samples[splitTimes[i]]),
          lastPose: getPose(samples[splitTimes[i + 1]]),
          nameError
        });
      }
    }
  }
  return trajList;
}

function printChoreoTraj(traj: ChoreoTraj): string {
  return `${traj.nameError !== undefined ? `/**ERROR: ${traj.nameError.uiMessage}. ${traj.nameError.codegenMessage}*/\n\t` : ""}public static final ChoreoTraj ${traj.varName} = new ChoreoTraj(
    "${traj.trajName}",
    ${traj.segment === undefined ? "OptionalInt.empty()" : `OptionalInt.of(${traj.segment})`},
    ${traj.totalTimeSecs},
    ${formatPose(traj.firstPose)},
    ${formatPose(traj.lastPose)}
);`;
}

const CHOREOLIB_HELPERS = `
    // If these methods cause errors because you're not using ChoreoLib,
    // turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
    /**
     * Load an AutoTrajectory directly from a ChoreoTraj, which may be a segment of a larger trajectory.
     */
    public AutoTrajectory asAutoTraj(AutoRoutine routine) {
        if (this.segment.isPresent()) {
            return routine.trajectory(this.name, this.segment.getAsInt());
        }
        return routine.trajectory(this.name);
    }
`.trimEnd();

const CHOREOLIB_HELPER_IMPORTS = `
import choreo.auto.AutoRoutine;
import choreo.auto.AutoTrajectory;
// If the imports above cause errors because you're not using ChoreoLib,
// turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
`.trimStart();

export function genTrajDataFile(
  trajectories: Trajectory[],
  packageName: string,
  isUsingChoreoLib: boolean
): string {
  const trajList = getChoreoTrajList(trajectories);
  console.log(trajList);
  try {
    const content: string = `
package ${packageName};

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import java.util.Map;
import java.util.OptionalInt;

${isUsingChoreoLib ? CHOREOLIB_HELPER_IMPORTS : ""}
/**
 * A class containing the name, start pose, end pose, and total time of every Choreo trajectory.
 * This prevents your code from referencing deleted or misspelled trajectories,
 * and removes the need for JSON parsing to load a trajectory's essential data.
 * DO NOT MODIFY THIS FILE YOURSELF! It is automatically generated by Choreo.
 */
public record ${TRAJ_DATA_FILENAME}(
    String name,
    OptionalInt segment,
    double totalTimeSecs,
    Pose2d initialPoseBlue,
    Pose2d endPoseBlue
) {
    ${trajList
      .map(printChoreoTraj)
      .map((item) => item.replaceAll("\n", "\n\t"))
      .join("\n\t")}

    /**
     * A map between trajectory names and their corresponding data.
     * This allows for trajectory data to be looked up with strings during runtime.
     */
    public static final Map<String, ChoreoTraj> ALL_TRAJECTORIES = Map.ofEntries(
    ${trajList
      .map((entry) => `\tMap.entry("${entry.mapName}", ${entry.varName})`)
      .join(",\n\t")}
    );

    /**
     * Looks up the ChoreoTraj segment of the given overall ChoreoTraj.
     * WARNING: will raise an exception if not called with a valid segment index.
     */
    public ChoreoTraj segment(int segment) {
        var traj = ChoreoTraj.ALL_TRAJECTORIES.get(this.name + "$" + segment);
        if (traj == null) {
            throw new NullPointerException("Trajectory " + this.name + " does not have segment #" + segment + ".");
        }
        return traj;
    }
    ${isUsingChoreoLib ? CHOREOLIB_HELPERS : ""}
}
`;
    return content;
  } catch (e) {
    tracing.error("Error generating trajectory data file:", e);
    throw e;
  }
}
